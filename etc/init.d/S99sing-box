#!/bin/sh

# Информация о службе
# Краткое описание: Запуск / Остановка sing-box

# Путь к JSON-файлу с настройками
if [ ! -f /opt/etc/swave/settings.json ]; then
    echo "Файл настроек /opt/etc/swave/settings.json не найден."
    echo "Пожалуйста, ознакомьтесь с примером настроек: /opt/etc/swave/example.json"
    echo "Отредактируйте его в соответствии с вашими требованиями,"
    echo "затем переместите в нужное место командой:"
    echo "  mv /opt/etc/swave/example.json /opt/etc/swave/settings.json"
    exit 1
else
    SETTING="/opt/etc/swave/settings.json"
fi

get_clean_json() {
  awk '
  BEGIN { in_string = 0 }
  {
    line = $0
    result = ""
    for (i = 1; i <= length(line); i++) {
      char = substr(line, i, 1)
      next_char = substr(line, i+1, 1)
      if (char == "\"" && prev != "\\") {
        in_string = !in_string
      }
      if (!in_string && char == "/" && next_char == "/") {
        break
      }
      result = result char
      prev = char
    }
    print result
  }' "$1"
}

js_SETTING=$(get_clean_json "$SETTING" | jq -c '.' 2>/dev/null)

DEBUG=false
DEBUG_LOG=$(echo "$js_SETTING" | jq -r '.app.log')

# Функция для отладки
debug() {
    [ "$DEBUG" = "true" ] && {
        _YELLOW='\033[33m'
        _NC='\033[0m'  # No Color
        echo -e "${_YELLOW}[DEBUG]${_NC} $*"          # Вывод в терминал
    #    logger -p debug -t "$(basename "$0")" "$*"  # И в syslog (опционально)
    #    echo "$(date) $*" >> "$DEBUG_LOG"           # И в файл (опционально)
    }
}

# Включение трассировки (если нужно)
#[ "$DEBUG" = "true" ] && set -x

# Выключение трассировки (если включали)
[ "$DEBUG" = "true" ] && set +x

# Пример использования
#chain_name=$(echo "$js_SETTING" | jq -r '.network.chain_name')
#debug "Наименование цепочки ${chain_name}"


# Цвета
color_green="\033[32m"    # Успешное выполнение, позитивные сообщения
color_red="\033[31m"      # Критические ошибки, опасные действия
color_yellow="\033[33m"   # Предупреждения, не критичные проблемы
color_blue="\033[34m"
color_reset="\033[0m"     # Сброс цвета к стандартному

IP_RULES_LOG=$(echo "$js_SETTING" | jq -r '.app.log')

# Если переменная не задана, используем /dev/null
LOG_FILE="${IP_RULES_LOG:-/dev/null}"


get_policy_mark() {

  # Определяем коды цветов (используем $'...' для интерпретации escape-последовательностей)
  _color_red=$'\033[31m'
  _color_reset=$'\033[0m'
  _test="test1"

  policy_mark=$(
      curl -kfsS "localhost:79/rci/show/ip/policy" \
      | jq -r --arg policy "$(echo "$js_SETTING" | jq -r '.network.connection_policy')" '
          .[]
          | select(.description
          | ascii_downcase == ($policy | ascii_downcase))
          | .mark'
  )

  if [ -z "$policy_mark" ]; then
      printf "%s %s[ERROR]%s Не удалось получить отметку о политике для: %s\n" \
        "$(date '+%Y-%m-%d %H:%M:%S')" \
        "$_color_red" \
        "$_color_reset" \
        "$(echo "$js_SETTING" | jq -r '.network.connection_policy')" >&2
      logger -t "$(basename "$0")" "Не удалось получить отметку о политике для: $(echo "$js_SETTING" | jq -r '.network.connection_policy')"
      return 1
  fi

  echo "0x${policy_mark}"
}


init_ip_rules() {

  ip_version="${1}"
  table_mark_hex=$(echo "$js_SETTING" | jq -r '.network.table_mark_hex')
  table_id=$(echo "$js_SETTING" | jq -r '.network.table_id')

  # Проверка, существует ли правило
  if ! busybox ip -"${ip_version}" rule show | grep -q "fwmark ${table_mark_hex} lookup ${table_id}" >/dev/null 2>&1; then

    policy_mark=$(get_policy_mark)

    # Если задан маркер политики, ищем связанную таблицу
    if [ -n "${policy_mark}" ]; then
      policy_table=$(busybox ip rule show | awk -v policy="${policy_mark}" '$0 ~ policy && /lookup/ && !/blackhole/ {print $NF}')
    fi

    # Добавляем правило и таблицу маршрутов
    busybox ip -"${ip_version}" rule add fwmark "${table_mark_hex}" lookup "${table_id}" >/dev/null 2>&1
    busybox ip -"${ip_version}" route add local default dev lo table "${table_id}" >/dev/null 2>&1

    # Копируем маршруты
    if [ -n "${policy_table}" ]; then
      busybox ip -"${ip_version}" route show table "${policy_table}" | grep -Ev '^default' |
      while IFS= read -r route; do
        matching_main_route=$(busybox ip -"${ip_version}" route show table "${policy_table}" | grep -F "${route}" || true)

        if [ -n "${matching_main_route}" ]; then
          busybox ip -"${ip_version}" route add table "${table_id}" ${matching_main_route} >/dev/null 2>&1
        else
          debug "WARN: Маршрут '${route}' не найден в основной таблице" >&2
        fi
      done
    else
        debug "ERROR: Маршрут не установлен"
    fi
    # shellcheck disable=SC3037
    debug "$(date '+%Y-%m-%d %H:%M:%S') ${color_green}[SUCCESS]${color_reset} Таблица Swave для IPv"${ip_version}" успешна создана" >&2
  fi
}

del_iptables() {

  chain_name="${1}"
  for family in iptables ip6tables; do
    for table in nat mangle; do
      debug "[*] Проверка таблицы '$table' (${family})"
      if $family -t "$table" -S 2>/dev/null | grep -qP "^-N ${chain_name}\b"; then
        debug "[+] Очистка цепочки '${chain_name}' в таблице '$table' (${family})"
        $family -t "$table" -F "${chain_name}"

        debug "[+] Удаление переходов в цепочку '${chain_name}' в таблице '$table' (${family})"
        while $family -t "$table" -S 2>/dev/null | grep -P "^-A .+ -j ${chain_name}\b" >/dev/null; do
          local rule=$($family -t "$table" -S 2>/dev/null | grep -P "^-A .+ -j ${chain_name}\b" | head -n 1)
          eval $family -t "$table" ${rule/-A/-D}
        done

        debug "[+] Удаление цепочки '${chain_name}' в таблице '$table' (${family})"
        $family -t "$table" -X "${chain_name}"
      else
        debug "[!] Цепочка '${chain_name}' не найдена или не является пользовательской в таблице '$table' (${family})"
      fi
    done
  done
}

del_ip_rules() {

  ip_version="${1}"

  table_mark_hex=$(echo "$js_SETTING" | jq -r '.network.table_mark_hex')
  table_id=$(echo "$js_SETTING" | jq -r '.network.table_id')


  if busybox ip -"${ip_version}" rule show | grep -q "fwmark ${table_mark_hex} lookup ${table_id}" >/dev/null 2>&1; then
    busybox ip -"${ip_version}" rule del fwmark ${table_mark_hex} lookup ${table_id} >/dev/null 2>&1
    busybox ip -"${ip_version}" route flush table ${table_id} >/dev/null 2>&1
    # shellcheck disable=SC3037
    debug "$(date '+%Y-%m-%d %H:%M:%S') ${color_green}[SUCCESS]${color_reset} Таблица маршрута для Swave успешна удалена" >&2
  fi
}

backup_config_sing_box() {

    SOURCE_DIR="$(echo "$js_SETTING" | jq -r '.client.path_config')"
    BACKUP_BASE_DIR="/opt/backups/sing-box"
    TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
    BACKUP_DIR="${BACKUP_BASE_DIR}/${TIMESTAMP}"

    # Проверяем существование базовой директории
    if [ ! -d "$BACKUP_BASE_DIR" ]; then
        echo "Директория $BACKUP_BASE_DIR не существует."
        echo -n "Хотите создать её? (y/n): "
        read answer
        if [ "$answer" = "y" ] || [ "$answer" = "Y" ]; then
            mkdir -p "$BACKUP_BASE_DIR"
            echo "Директория создана: $BACKUP_BASE_DIR"
        else
            echo "Операция отменена пользователем."
            return 1
        fi
    fi

    # Создаём папку для нового бэкапа
    mkdir -p "$BACKUP_DIR"

    # Копируем файлы
    cp -r "$SOURCE_DIR/"* "$BACKUP_DIR/"

    echo "Бэкап успешно создан в: $BACKUP_DIR"
}

IPv6=$(echo "$js_SETTING" | jq -r '.network.IPv6 // "false"')

if [ "$(cat /proc/sys/net/ipv6/conf/all/disable_ipv6 2>/dev/null)" -eq 0 ]; then
    echo "IPv6 включён в системе."
else
    echo "IPv6 отключён или не поддерживается."
    IPv6=false
fi

# Менеджер команд
case "${1}" in
start)
    policy_mark=$(get_policy_mark) || {
    # shellcheck disable=SC3037
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') ${color_yellow}[INFO]${color_reset} Добавьте политику Swave на вашем роутере " >&2
    exit 1
    }
    init_ip_rules 4
    [ "$IPv6" = "true" ] && init_ip_rules 6

    if [ -f ./etc/ndm/netfilter.d/000-swave.sh ]; then
        . ./etc/ndm/netfilter.d/000-swave.sh
    else
        . /opt/etc/ndm/netfilter.d/000-swave.sh
    fi
    export SSL_CERT_DIR=/opt/etc/ssl/certs
    #sing-box run -D /opt/var/sing-box -C "$(echo "$js_SETTING" | jq -r '.client.path_config')" 2>> "${LOG_FILE}" &
    { echo -e "\n=== $(date) === sing-box client info ==="; sing-box run -D /opt/var/sing-box -C "$(echo "$js_SETTING" | jq -r '.client.path_config')"; } >> "${LOG_FILE}" 2>&1 &
    "$0" status
    ;;
stop)
    del_ip_rules 4
    del_ip_rules 6
    chain_name=$(echo "$js_SETTING" | jq -r '.network.chain_name')
    chain_name_output="${chain_name}"_out
    del_iptables "${chain_name}"
    del_iptables "${chain_name_output}"
    busybox killall -q -9 "$(echo "$js_SETTING" | jq -r '.client.name')"
    "$0" status
    ;;
status)
    name_client=$(echo "$js_SETTING" | jq -r '.client.name')
    if pgrep -f "${name_client} run" > /dev/null; then
      echo -e " ${name_client} ${color_green}запущен${color_reset}"
    else
      echo -e " ${name_client} ${color_red}отключён${color_reset}"
    fi
    ;;
backup)
    backup_config_sing_box
  ;;
restart)
    "$0" stop
    "$0" start
    ;;
*)
    echo -e "  Команды: ${color_green}start${color_reset} | ${color_red}stop${color_reset} | ${color_yellow}restart${color_reset} | ${color_blue}backup${color_reset} | status"
    ;;
esac

exit 0
